<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="gaylong9">



    <meta name="description" content="年更博客 自娱自乐">



<title>Spring-5-数据库事务管理 | gaylong9`s blog</title>
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">gaylong9&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">gaylong9&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Spring-5-数据库事务管理</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">gaylong9</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 03, 2021&nbsp;&nbsp;09:56:35</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>&nbsp;</p>
<span id="more"></span>
<!-- toc -->
<p>&nbsp;</p>
<p>[toc]</p>
<p>&nbsp;</p>
<h1 id="1-Spring数据库事务管理器"><a href="#1-Spring数据库事务管理器" class="headerlink" title="1. Spring数据库事务管理器"></a>1. Spring数据库事务管理器</h1><p>Spring中数据库事务通过PlatformTransactionManager管理。</p>
<p>jdbcTemplate是Spring中数据库功能的重要模板类，而TransactionTemplate是完成事务管理的重要模板类。</p>
<p>在TransactionTemplate中：</p>
<ul>
<li>事务的创建、回滚、提交是通过PlatformTransactionManager事务管理器接口完成的</li>
<li>回滚时默认所有异常都回滚，可配置修改为仅部分异常回滚或不回滚</li>
<li>无异常时提交</li>
</ul>
<p>而PlatformTransactionManager接口及其继承、实现族：常用DataSourceTransactionManager，继承自AbstractPlatformTransactionManager，实现自PlatformTransactionManager。</p>
<p>PlatformTransactionManager接口具有三个方法：</p>
<ol>
<li><code>TransactionStatus getTransaction(TransactionDefinition) throws TransactionException;</code> 获取事务状态</li>
<li><code>void commit(TransactionStatus) throws TransactionException;</code> 提交</li>
<li><code>void rollback(TransactionStatus) throws TransactionException;</code> 回滚</li>
</ol>
<p>&nbsp;</p>
<h2 id="1-1-配置事务管理器"><a href="#1-1-配置事务管理器" class="headerlink" title="1.1 配置事务管理器"></a>1.1 配置事务管理器</h2><p>MyBatis最常用DataSourceTransactionManager事务管理器，Hibernate中常用spring-orm包中的HibernateTransactionManager。</p>
<p>XML配置时加入事务命名空间：</p>
<p><code>http://www.springframework.org/schema/tx</code></p>
<p><code>http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时，Spring就知道已将数据库事务委托给事务管理器transactionManager管理了。且jdbcTemplate中，若数据库资源的产生和释放没有委托管理器就由jdbcTemplate自己管理；此时委托给事务管理器，所以数据库资源和事务就由事务管理器处理。</p>
<p>Spring中可以使用声明式事务和编程式事务，后者因为冗余，几乎废弃；前者又可通过XML和注解配置，但XML也已不常用，主流使用@Transactional注解标识。即，<strong>主流使用注解配置的声明式事务</strong>。</p>
<p>&nbsp;</p>
<h2 id="1-2-Java配置实现Spring数据库事务"><a href="#1-2-Java配置实现Spring数据库事务" class="headerlink" title="1.2 Java配置实现Spring数据库事务"></a>1.2 Java配置实现Spring数据库事务</h2><p>用Java配置的方式实现Spring数据库事务，需要在配置类中实现接口TransactionManagerConfigurer的annotationDrivenTransactionManager方法。Spring把此方法返回的事务管理器作为程序中的事务管理器。</p>
<p>？</p>
<p>&nbsp;</p>
<h1 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2. 编程式事务"></a><del>2. 编程式事务</del></h1><p>逐渐弃用。</p>
<p>用代码实现事务管理。需要事务定义类接口TransactionDefinition，具有默认实现类DefaultTransactionDefinition。使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">PlatformTransactionManager transactionManager = ctx.getBean(PlatformTransactionManager.class);</span><br><span class="line">TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jdbcTemplate.update(sql);</span><br><span class="line">    transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事务已交给管理器控制，故jdbcTemplate完成SQL后不会提交，等待管理器的commit或rollback。</p>
<p>&nbsp;</p>
<h1 id="3-声明式事务"><a href="#3-声明式事务" class="headerlink" title="3. 声明式事务"></a>3. 声明式事务</h1><h2 id="3-1-Transactional配置项"><a href="#3-1-Transactional配置项" class="headerlink" title="3.1 @Transactional配置项"></a>3.1 @Transactional配置项</h2><div class="table-container">
<table>
<thead>
<tr>
<th>配置项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>定义事务管理器，是IoC的一个Bean id，需要实现PlatformTransactionManager</td>
</tr>
<tr>
<td>transactionManager</td>
<td>同上</td>
</tr>
<tr>
<td>isolation</td>
<td>隔离级别</td>
</tr>
<tr>
<td>propagation</td>
<td>传播行为，默认REQUIRED</td>
</tr>
<tr>
<td>timeout</td>
<td>超时s，引发异常，默认导致回滚</td>
</tr>
<tr>
<td>readOnly</td>
<td>是否开启只读事务，默认false</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>回滚的异常类定义，即方法产生了定义的异常时才回滚</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>回滚的异常类名定义</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>哪些异常不会滚，继续提交</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>同上</td>
</tr>
</tbody>
</table>
</div>
<p>这些属性会被Spring放到TransactionDefinition事务定义器中。且使用声明式事务需要配置注解驱动，在Spring-cfg.xml中加入<code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code>。</p>
<blockquote>
<p>此处遇到一个小Bug：xml命名空间处，IDEA自动生成<code>xmlns:tx=&quot;http://www.springframework.org/schema/cache&quot;</code>，需改为<code>.../tx</code></p>
</blockquote>
<p>&nbsp;</p>
<h2 id="3-2-使用XML配置事务管理器"><a href="#3-2-使用XML配置事务管理器" class="headerlink" title="3.2 使用XML配置事务管理器"></a><del>3.2 使用XML配置事务管理器</del></h2><p>XML配置事务管理器方法很多但不常用，一般采用注解配置。</p>
<p>XML配置需要一个事务拦截器TransactionInterceptor。IoC启动时解析XML中拦截器的属性，放到事务定义类TransactionDefinition中，再运行时根据正则式匹配决定方法策略。显然，声明式事务的底层原理就是Spring AOP技术。</p>
<p>此外还需配置BeanNameAutoProxyCreator，指明Spring要拦截哪些类。</p>
<p>&nbsp;</p>
<h2 id="3-3-事务定义器"><a href="#3-3-事务定义器" class="headerlink" title="3.3 事务定义器"></a>3.3 事务定义器</h2><p>本接口中，有传播行为常量、隔离级别定义，有获取传播行为方法、获取隔离界别方法、获取事务超时时间方法、是否只读事务方法、获取事务定义器名称方法。事务的大多配置都可在此完成。</p>
<p>&nbsp;</p>
<h2 id="3-4-声明式事务的约定流程"><a href="#3-4-声明式事务的约定流程" class="headerlink" title="3.4 声明式事务的约定流程"></a>3.4 声明式事务的约定流程</h2><p>@Transaction注解，可以用在类或方法上。在IoC容器初始化时，Spring读入注解（或XML）配置的事务信息，保存到一个事务定义类中（TransactionDefinition接口的子类）。运行时Spring拦截注解标注的方法或类，根据AOP，把自定义的功能织入AOP流程。</p>
<p>首先Spring通过事务管理器（PlatformTransactionManager的子类）创建事务，同时把事务定义中的隔离级别、超时等属性根据配置设置到事务上。根据传播行为配置采取特定策略。运行中，Spring反射调用代码，根据约定决定是回滚还是提交。整个过程中，只需要编写业务代码和对事务属性配置即可，代码量少逻辑清晰。</p>
<p><img src="Spring-5-数据库事务管理/声明式事务流程.png" alt="声明式事务流程"></p>
<p>如插入角色：无需打开数据库，链接资源，提交回滚释放等，只需注解Transactional。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RoleDao roleDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED, isolation=Isolation.DEFAULT, timeout=3)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertRole</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> roleDao.insert(role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h1 id="4-数据库相关"><a href="#4-数据库相关" class="headerlink" title="4. 数据库相关"></a>4. 数据库相关</h1><h2 id="4-1-隔离级别"><a href="#4-1-隔离级别" class="headerlink" title="4.1 隔离级别"></a>4.1 隔离级别</h2><p>SQL标准把隔离级别定义为4层；脏读、读写提交、可重复读、序列化。</p>
<ol>
<li>脏读：可以读取另一个事务中未提交的数据，会引发脏读</li>
<li>读写提交：只能读取其他事务已提交的数据，克服脏读但不能避免不可重复读</li>
<li>可重复读：针对同一记录的概念，是同一记录的读写操作按照一个序列化进行，不交叉，实现了可重复读，但不能避免幻读</li>
<li>序列化：让SQL按顺序读写，解决幻读</li>
</ol>
<p>&nbsp;</p>
<h2 id="4-2-选择隔离级别"><a href="#4-2-选择隔离级别" class="headerlink" title="4.2 选择隔离级别"></a>4.2 选择隔离级别</h2><p>为平衡性能与数据一致性，通常选择读/写提交（二级隔离 Isolation.READ_COMMIT）。之后还有其他方法维护数据一致性。注解Transactional的隔离级别默认Isolation.DEFAULT，代表随数据库默认值而变化。如MySQL中默认可重复读级别，Oracle只支持读写提交和可序列化两个级别，默认读写提交。</p>
<p>&nbsp;</p>
<h2 id="4-3-传播行为"><a href="#4-3-传播行为" class="headerlink" title="4.3 传播行为"></a>4.3 传播行为</h2><p>指方法之间调用事务策略的问题。通常希望事务能同时成功或同时失败，但也有一些时候希望只回滚部分事务。如还款时，Batch类batch方法记录还款总人数等信息，Service类的repay完成某一张卡的还款，若仅一个事务，则一旦有一个人异常，则所有人回滚；此时可以改用batch方法调用repay，每次调用产生一个新事务，则有人异常只回滚他自己。</p>
<p>这种一个方法调度另一个方法，可以对事务的特性进行传播配置，就成为传播行为。</p>
<p>Spring中的传播特性是枚举类Propagation定义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED</td>
<td>调用时，若不存在当前事务就创建事务；若前一个方法已有事务就沿用（默认）</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>调用时，若不存在当前事务就不启用事务；若存在就沿用</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>方法必须在事务内运行，不存在当前事务就异常</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>无论是否存在事务，方法都在新事务中运行</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不支持事务，若不存在事务也不创建；存在事务就挂起，至方法结束才恢复，适用于不需事务的SQL</td>
</tr>
<tr>
<td>NEVER</td>
<td>不支持事务，只有不存在事务时才能运行，否则异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>嵌套事务，调用方法若异常只回滚自己内部的SQL，不回滚主方法SQL；通过保存点技术实现，若库不支持保存点，就REQUIRES_NEW</td>
</tr>
</tbody>
</table>
</div>
<p>常用默认的REQUIRED，也会用到REQUIRES_NEW和NESTED。</p>
<p>&nbsp;</p>
<h1 id="5-MS中使用事务"><a href="#5-MS中使用事务" class="headerlink" title="5. MS中使用事务"></a>5. MS中使用事务</h1><p>本例中使用两个接口与两个实现类，两类有调用关系，被调用类完成insert，以测试传播与隔离。</p>
<p>首先新建两个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookListService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 会调用BookService的insertBook方法，用于测试传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBookList</span><span class="params">(List&lt;Book&gt; bookList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实例化；类中包含Mapper实例对象，即MyBatis中所有数据库操作最终是通过Mapper执行，且注意此处两方法都设置了Transactional注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW,</span></span><br><span class="line"><span class="meta">            isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = bookMapper.insertBook(book);</span><br><span class="line">        System.out.println(<span class="string">&quot;insert a book &quot;</span> + book.getTitle());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookListServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookListService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">            isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBookList</span><span class="params">(List&lt;Book&gt; bookList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Book book: bookList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                count += bookService.insertBook(book);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                System.err.println(exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML配置：使用XML配置，开启扫描本包即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;Transaction&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring_config.xml&quot;</span>);</span><br><span class="line">BookListService bookListService = context.getBean(BookListService.class);</span><br><span class="line">List&lt;Book&gt; bookList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> book6 = <span class="keyword">new</span> Book(<span class="string">&quot;006&quot;</span>, <span class="string">&quot;title6&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> book7 = <span class="keyword">new</span> Book(<span class="keyword">null</span>, <span class="string">&quot;title7&quot;</span>);</span><br><span class="line">bookList.add(book6);</span><br><span class="line">bookList.add(book7);</span><br><span class="line"><span class="keyword">int</span> count = bookListService.insertBookList(bookList);</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>
<p>在当前两类的传播设置下（调用方法是REQUIRED，被调用方法是REQUIRES_NEW），即被调用方法中，每次使用mapper的insertBook都会新建事务，故前一本书添加成功，后一本书添加失败。</p>
<p>若改为REQUIRED和REQUIRED，则两本书的添加是同一事务，由于后者添加失败，前者也会被一并回滚。</p>
<p>若改为REQUIRES_NEW和REQUIRED，也会一并回滚。</p>
<p>若改为REQUIRED和NESTED，被调用方法内部单独回滚，程序仍能正常运行。</p>
<p>&nbsp;</p>
<h1 id="6-Transactional的自调用失效问题"><a href="#6-Transactional的自调用失效问题" class="headerlink" title="6. @Transactional的自调用失效问题"></a>6. @Transactional的自调用失效问题</h1><p>注解Transactional的底层实现是AOP技术，使用动态代理，则<strong>对static、非public方法，注解是失效的</strong>。此外，自调用也是容易出现的错误。</p>
<p>自调用：类的一个方法调用本类的其他方法。如上例中，BookServiceImpl类新增insertBookList方法调用自己的insertBook方法，且被调用方法使用REQUIRES_NEW传播行为，但观察日志可发现并没有每次新建事务，只使用了同一事务，即被调用方法的注解失效了。</p>
<p>原因：动态代理过程中，类自己调用自己，不存在代理对象的调用，就不会产生AOP设置注解的参数。</p>
<p>解决：如上例中使用两个服务类；或在调用方法中获取代理对象，然后用代理对象执行被调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="meta">@Transactional(...)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBookList</span> <span class="params">(List&lt;Book&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从容器获取代理对象</span></span><br><span class="line">    BookService service = ctx.getBean(RoleService.class);</span><br><span class="line">    <span class="keyword">for</span> (Book book : list) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            service.insertBook(book);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h1 id="7-典型错误用法"><a href="#7-典型错误用法" class="headerlink" title="7. 典型错误用法"></a>7. 典型错误用法</h1><ol>
<li><p>错误使用Service</p>
<p> Service服务类。在MVC中的Controller中使用服务类很正常，如要在一个Controller中插入两个角色，并且要求两角色在同一事务中处理。但如果服务类的方法，指定了@Transactional的新建事务的传播行为，则简单地先后调用插入方法是无法完成同一事务中处理的要求的。</p>
</li>
<li><p>过长时间占用事务</p>
<p> 使用事务资源后要尽快释放，操作文件、对外连接等耗时且与数据库无关的操作应剥离，即不放在@Transactional标注的方法内。</p>
</li>
<li><p>错误捕捉异常</p>
<p> 在Transactional方法中，可以try-catch自行捕获异常，但如果需要Spring回滚，就要手动在catch中继续throw异常，让容器接收异常，自动回滚；否则try中代码部分完成部分异常执行失败，且没有异常出现，就不会自动回滚。</p>
</li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%90%8E%E7%AB%AF/"># 后端</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/04/04/SpringMVC-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B5%81%E7%A8%8B/">SpringMVC-1-初始化和流程</a>
            
            
            <a class="next" rel="next" href="/2021/04/01/Spring-4-Spring%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/">Spring-4-Spring和数据库编程</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© gaylong9 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
