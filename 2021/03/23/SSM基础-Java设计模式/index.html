<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="gaylong9">



    <meta name="description" content="年更博客 自娱自乐">



<title>SSM基础-Java设计模式 | gaylong9`s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">gaylong9&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">gaylong9&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">SSM基础-Java设计模式</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">gaylong9</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 23, 2021&nbsp;&nbsp;09:19:50</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p> </p>
<a id="more"></a>
<!-- toc -->
<ul>
<li><a href="#java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Java设计模式</a>
<ul>
<li><a href="#1-java%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF">1. Java反射技术</a>
<ul>
<li><a href="#11-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1">1.1 通过反射构建对象</a></li>
<li><a href="#12-%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95">1.2 反射方法</a></li>
<li><a href="#13-%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B">1.3 反射实例</a></li>
</ul>
</li>
<li><a href="#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">2. 动态代理模式和责任链模式</a>
<ul>
<li><a href="#21-jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.1 JDK动态代理</a></li>
<li><a href="#22-cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">2.2 CGLIB动态代理</a></li>
<li><a href="#23-%E6%8B%A6%E6%88%AA%E5%99%A8">2.3 拦截器</a></li>
<li><a href="#24-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">2.4 责任链模式</a></li>
</ul>
</li>
<li><a href="#3-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-observer">3. 观察者模式 Observer</a></li>
<li><a href="#4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">4. 工厂模式和抽象工厂模式</a>
<ul>
<li><a href="#41%E6%99%AE%E9%80%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">4.1普通工厂模式</a></li>
<li><a href="#42-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">4.2 抽象工厂模式</a></li>
</ul>
</li>
<li><a href="#5-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-builder">5. 建造者模式 Builder</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p> </p>
<p>[toc]</p>
<h1><span id="java设计模式"> Java设计模式</span></h1>
<h2><span id="1-java反射技术"> 1. Java反射技术</span></h2>
<p>反射技术能够配置类的全限定名、方法和参数、完成对象初始化操作、甚至反射某些方法。Spring IoC的基本原理也是反射技术。</p>
<p>Java反射内容繁多，本章重点讲解对象构建和方法的反射调用。Java中反射是通过包java.lang.reflect.*实现。</p>
<h3><span id="11-通过反射构建对象"> 1.1 通过反射构建对象</span></h3>
<ol>
<li>
<p>无参构造：如ReflectSample类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射方式构建对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectSample <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReflectSample obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = (ReflectSample) Class.forName(<span class="string">"xxx.ReflectSample"</span>).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Class.forName().newInstance()</code>是给类加载器注册一个类ReflectSample的全限定名，然后通过newInstance方法初始化一个对象。本例是一个无参构造的类。</p>
</li>
<li>
<p>有参构造：以ReflectSample2类为例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectSample2</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的反射构建对象：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectSample2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReflectSample2 obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = (ReflectSample2) Class.forName("xxx.ReflectSample2").getConstructor(String.class).newInstance("Tom");</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中的反射，先用forName加载到类的加载器，然后通过getConstructor方法 ，它的参数可以是多个，这里的String.class表示只有一个参数类型为String的构建方法，再用newInstance方法生成对象，实际等价于<code>obj = new ReflectSample2(&quot;Tom&quot;)</code>，只是使用了反射机制。</p>
</li>
<li>
<p>反射只要配置就可生成对象，可以降低耦合，比较灵活，但比较慢。</p>
</li>
</ol>
<p> </p>
<h3><span id="12-反射方法"> 1.2 反射方法</span></h3>
<p>使用反射方法前要先获取对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reflectMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    ReflectSample target = <span class="keyword">new</span> ReflectSample();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = ReflectSample.class.getMethod("sayHello", String.class);</span><br><span class="line">        obj = method.invoke(target, <span class="string">"Tom"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>ReflectSample.class.getMethod()</code>，若有对象但不知道类时，可以使用<code>target.getClass().getMethod()</code>，getMethod中第一个参数是方法名，第二个参数是方法参数类型，是一个列表。</p>
<p>具体反射方法的执行是<code>method.invoke()</code>实现，等价于<code>target.sayHello(&quot;Tom&quot;)</code>，若反射的方法有多个参数，则<code>invoke(target, obj1, obj2…)</code>即可。</p>
<p> </p>
<h3><span id="13-反射实例"> 1.3 反射实例</span></h3>
<p>完整通过反射创建对象并调用方法，继续以ReflectSample为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reflect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReflectSample obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = (ReflectSample) Class.forName(<span class="string">"xxx.ReflectSample"</span>).newInstance();</span><br><span class="line">        Method method = obj.getClass().getMethod(<span class="string">"sayHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method.invoke(obj, <span class="string">"Tom"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此完全可以通过配置来完成对象和方法的反射，增强了Java的可配置性和可扩展性，IoC就是基于此法的典型例子。</p>
<p> </p>
<h2><span id="2-动态代理模式和责任链模式"> 2. 动态代理模式和责任链模式</span></h2>
<ol>
<li>动态代理是生成一个代理对象（占位），来代理真实对象，从而控制真实对象的访问</li>
<li>代理模式：调用者与代理对象联系，代理对象与真实对象联系，如此可在访问真实对象的前或后，加入其它逻辑，并且可以判断是否需要访问真实对象等</li>
<li>故代理分两步：代理对象和真实对象建立代理关系、实现代理对象的代理逻辑方法</li>
<li>Java有多种动态代理技术，Spring常用JDK（JDK自带功能）和CGLIB（第三方），MyBatis还使用了Javassist</li>
</ol>
<h3><span id="21-jdk动态代理"> 2.1 JDK动态代理</span></h3>
<p>是JDK自带功能，java.lang.reflect.*提供的方式，必须<strong>借助一个接口</strong>才能产生代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口，其中定义的方法将是代理过程中可以代理执行的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syaHelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类，也是代理中的真实对象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImp</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来需要将代理对象和真实对象绑定，并实现代理对象的代理逻辑方法。JDK动态代理中，要实现代理类必须实现java.lang.reflect.InvocationHandler接口，定义了invoke方法，并提供接口数组用于下挂代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理方法逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 当前调度方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 当前方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理结果返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之前的服务"</span>);</span><br><span class="line">        <span class="comment">// 通过反射调用真实对象的方法</span></span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之后的服务"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步建立代理和真实对象联系时，<code>Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this)</code>，第一个参数是真实对象的类加载器；第二个参数是要把生成的动态代理对象下挂在哪些接口，即最开始创建并实现的接口HelloWorld，则代理对象就可以通过<code>HelloWorld proxy = xxx;</code>声明；第三个参数是定义实现方法逻辑的代理类，需要实现InvocationHandler的invoke方法，它就是代理逻辑方法的实现方法。</p>
<p>第二步实现代理逻辑方法。invoke实现代理逻辑，有3个参数：proxy代理对象，就是bind生成的对象；method当前调度的犯法；args调度方法的参数。</p>
<p>最后测试此动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line">    <span class="comment">// 绑定，得到代理对象</span></span><br><span class="line">    HelloWold proxy = (HelloWorld) jdk.bind(<span class="keyword">new</span> HelloWorldImp());</span><br><span class="line">    <span class="comment">// 已代理，调用逻辑方法</span></span><br><span class="line">    proxy.sayHelloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行将会输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入代理逻辑方法</span><br><span class="line">在调度真实对象之前的服务</span><br><span class="line">Hello World.</span><br><span class="line">在调度真实对象之后的服务</span><br></pre></td></tr></table></figure>
<p> </p>
<h3><span id="22-cglib动态代理"> 2.2 CGLIB动态代理</span></h3>
<p>JDK动态代理只能提供接口才能使用，若不能提供接口，就要用其他第三方技术，如CGLIB动态代理，它只要一个非抽象类就能实现动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyExample</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成CGLIB代理对象 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cls -- 真实对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> CGLIB代理对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// CGLIB enhancer增强类对象</span></span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		<span class="comment">// 设置增强类型</span></span><br><span class="line">		enhancer.setSuperclass(cls);</span><br><span class="line">		<span class="comment">// 定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor方法</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 生成并返回代理对象</span></span><br><span class="line">		<span class="keyword">return</span> enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 代理逻辑方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 代理逻辑返回</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Throwable异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.err.println(<span class="string">"调用真实对象前"</span>);</span><br><span class="line">		<span class="comment">// CGLIB反射调用真实对象方法</span></span><br><span class="line">		Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">		System.err.println(<span class="string">"调用真实对象后"</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了CGLIB的加强者Enhancer，通过设置超类的方法（setSuperclass），通过setCallback方法设置哪个类为它的代理类。其中 参数this意味着是当前对象，就要求用this对象实现接口MethodInterceptor的方法intercept，然后返回代理对象。如此，当前类的intercept方法就是代理逻辑方法。</p>
<p>测试代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCGLIBProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CglibProxyExample cpe = <span class="keyword">new</span> CglibProxyExample();</span><br><span class="line">    ReflectSample obj = (ReflectSample)cpe.getProxy(ReflectSample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    obj.sayHello(<span class="string">"Tom"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用真实对象前</span><br><span class="line">Hello Tom</span><br><span class="line">调用真实对象后</span><br></pre></td></tr></table></figure>
<p>JDK与CGLIB动态代理都是用getProxy方法生成代理对象，制定代理的逻辑类。代理逻辑类要实现一个接口的一个方法，那么这个接口定义的方法就是代理对象的逻辑方法，可以控制真实对象的方法。</p>
<p> </p>
<h3><span id="23-拦截器"> 2.3 拦截器</span></h3>
<p>由于动态代理的难以理解，通过设计者会设计一个拦截器接口供开发者使用，可将动态代理置入黑箱。</p>
<p>用JDK动态代理实现一个拦截器，首先需要定义拦截器接口Interceptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数proxy代理对象、target真实对象、method方法、args运行方法参数。</p>
<p>before方法返回boolean，在真实对象前调用，返回true时才反射真实对象的方法，若返回false则调用around方法。</p>
<p>在反射真实对象方法或around方法执行后，调用after方法。</p>
<p>接口实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">		System.err.println(<span class="string">"反射方法前逻辑"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 不反射被代理对象原有方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">		System.err.println(<span class="string">"反射方法后逻辑。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">		System.err.println(<span class="string">"取代了被代理对象的方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本类实现了接口的所有方法，使用JDK动态代理，就能实现这些方法的适时调用逻辑。</p>
<p>在JDK动态代理中使用拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">//真实对象</span></span><br><span class="line">    <span class="keyword">private</span> String interceptorClass = <span class="keyword">null</span>;<span class="comment">//拦截器全限定名</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterceptorJdkProxy</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClass = interceptorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定真实对象并返回一个代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取得代理对象    </span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), </span><br><span class="line">                <span class="keyword">new</span> InterceptorJdkProxy(target, interceptorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过代理对象调用方法，首先进入这个方法.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy --代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method --方法，被调用方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args -- 方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptorClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有设置拦截器则直接反射原有方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过反射生成拦截器</span></span><br><span class="line">        Interceptor interceptor = </span><br><span class="line">            (Interceptor) Class.forName(interceptorClass).newInstance();</span><br><span class="line">        <span class="comment">//调用前置方法</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            <span class="comment">//反射原有对象方法</span></span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//返回false执行around方法</span></span><br><span class="line">            interceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用后置方法</span></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在bind方法中用JDK动态代理绑定了真实对象，返回代理对象。</p>
<p>然后若没有设置拦截器，则直接反射真实对象的方法，随后结束。</p>
<p>若有拦截器，则通过反射生成拦截器，并使用。</p>
<p>测试拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterceptorJDKProxy</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(<span class="keyword">new</span> HelloWroldImp(), <span class="string">"xxx.MyInterceptor"</span>);</span><br><span class="line">    proxy.sayHelloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于MyInterceptor中，before方法指定返回false，故输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反射方法前逻辑。</span><br><span class="line">取代了被代理对象的方法。</span><br><span class="line">反射方法后逻辑。</span><br></pre></td></tr></table></figure>
<p> </p>
<h3><span id="24-责任链模式"> 2.4 责任链模式</span></h3>
<p>当一个对象在一条链上被多个拦截器拦截处理时，就把这样的设计模式称为责任链模式。此模式下，可将原始对象层层动态代理，形成嵌套结构。即首先建立多个拦截器接口的实现类，代表多个拦截器，先后进行多次代理，使用前一次的代理对象当做后一次的真实对象。如此运行的话，会生成如下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拦截器2的before方法</span><br><span class="line">拦截器1的before方法</span><br><span class="line">Hello World，真实对象的方法</span><br><span class="line">拦截器1的after方法</span><br><span class="line">拦截器2的after方法</span><br></pre></td></tr></table></figure>
<p>可见，责任链模式优点在于可加入新的拦截器，增加拦截逻辑，但缺点是会增加代理和反射，而它们的性能都不高。</p>
<p> </p>
<h2><span id="3-观察者模式-observer"> 3. 观察者模式 Observer</span></h2>
<p>又称为发布订阅模式，是对象的行为模式。定义了一种一对多的依赖关系，让多个观察者对象同时监视被观察者状态，当被观察者变化时，通知所有观察者，并让它们主动更新自己。</p>
<p>如一个判断条件，决定很多后续执行的情况，若使用简单的if判断，则使得内容很多，需要大量catch以免后续执行之间的妨碍。而观察者模式更易于扩展，责任也更清晰。</p>
<p>本例为商家产品列表如有上新，则各个电商平台观察到后自动上新。</p>
<p>被观察者：需要继承java.util.Observable类，本例是商家的产品列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductList</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; productList = <span class="keyword">null</span>;<span class="comment">//产品列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ProductList instance;<span class="comment">//类唯一实例    </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProductList</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//构建方法私有化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得唯一实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 产品列表唯一实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductList <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ProductList();</span><br><span class="line">            instance.productList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加观察者（电商接口）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer 观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProductListObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  新增产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newProduct 新产品 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProudct</span><span class="params">(String newProduct)</span> </span>&#123;</span><br><span class="line">        productList.add(newProduct);</span><br><span class="line">        System.err.println(<span class="string">"产品列表新增了产品："</span>+newProduct);</span><br><span class="line">        <span class="keyword">this</span>.setChanged();<span class="comment">//设置被观察对象发生变化</span></span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(newProduct);<span class="comment">//通知观察者，并传递新产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建方法私有化，单例模式，只能通过getInstance方法获得实例。</p>
<p>观察者：需要实现Observer接口的update方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 京东接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingDongObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.err.println(<span class="string">"发送新产品【"</span>+newProduct+<span class="string">"】同步到京东商城"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 淘宝接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBaoObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.err.println(<span class="string">"发送新产品【"</span>+newProduct+<span class="string">"】同步到淘宝商城"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试本例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	ProductList observable = ProductList.getInstance();</span><br><span class="line">	TaoBaoObserver taoBaoObserver = <span class="keyword">new</span> TaoBaoObserver();</span><br><span class="line">	JingDongObserver jdObserver = <span class="keyword">new</span> JingDongObserver();</span><br><span class="line">	observable.addObserver(jdObserver);</span><br><span class="line">	observable.addObserver(taoBaoObserver);</span><br><span class="line">	observable.addProudct(<span class="string">"产品1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">产品列表新增了产品：产品1</span><br><span class="line">发送新产品【产品1】同步到淘宝商城</span><br><span class="line">发送新产品【产品1】同步到京东商城</span><br></pre></td></tr></table></figure>
<p> </p>
<h2><span id="4-工厂模式和抽象工厂模式"> 4. 工厂模式和抽象工厂模式</span></h2>
<p>对于同一大类下的诸多类，用户只需知道自己需要什么类，具体实例化交由工厂实现并返回。</p>
<h3><span id="41普通工厂模式"> 4.1普通工厂模式</span></h3>
<p>有一Product接口，有5个类实现了接口，为Product1、Product2、…、Product5，并且由ProductFactory同一管理。用户只需使用工厂中的createProduct方法，并传入所需序号，工厂即可实例化并返回对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span> <span class="params">(String productNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (productNo) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"1"</span>: <span class="keyword">return</span> <span class="keyword">new</span> Product1();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"5"</span>: <span class="keyword">return</span> <span class="keyword">new</span> Product5();</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> NotSuppportedException(<span class="string">"不支持此编号产品"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h3><span id="42-抽象工厂模式"> 4.2 抽象工厂模式</span></h3>
<p>普通工厂，解决了一类对象创建问题，但有时对象复杂，有很多种，同时又细分了几个类别。此时若只用一个工厂，就会造成工厂内部实现逻辑繁杂，这就需要划分工厂，但仍希望留一个统一的工厂给使用者，再由这个总工厂接收任务后下发给具体完成对象创建的分工厂。这里的总工厂并不实际存在，是通过各分厂实现的，称为抽象工厂。如此封装，简化了调用者的使用过程。</p>
<p>抽象工厂模式可以向调用者提供一个接口，使其在不必指定产品的具体情况下，创建多个产品族中的产品对象。</p>
<p>为了统一，首先需要定义一个接口，每个工厂（包括虚拟工厂）都要实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span> <span class="params">(String productNo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后创建两个分厂，用于实现工厂的具体实现方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory1</span> <span class="keyword">implements</span> <span class="title">ProductFactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span> <span class="params">(String productNo)</span> </span>&#123;</span><br><span class="line">        Product product = xxx;	<span class="comment">// 本分厂内生产的规则</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory2</span> <span class="keyword">implements</span> <span class="title">ProductFactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span> <span class="params">(String productNo)</span> </span>&#123;</span><br><span class="line">        Product product = xxx;	<span class="comment">// 本分厂内生产的规则</span></span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建总工厂/抽象工厂，并设定任务分发规则，即productNo编号，1开头则交由分厂1完成，2开头则交由分厂2完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span> <span class="params">(String productNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = productNo.charAt(<span class="number">0</span>);</span><br><span class="line">        ProductFactoryInter factory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'1'</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> ProductFactory1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'2'</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> ProductFactory2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> factory.createProduct(productNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此，就实现了抽象工厂与具体完成任务的分厂之间的联系。调用者只需通过抽象工厂发布任务，抽象工厂自动分发任务给分厂完成并返回结果。各分厂只需维护自己的代码即可。</p>
<p> </p>
<h2><span id="5-建造者模式-builder"> 5. 建造者模式 Builder</span></h2>
<p>属于对象的创建模式，可以将一个产品的属性与产品的生产过程分开，从而使一个建造过程生成具有不同属性的对象。</p>
<p>适用于对象具有较多属性，导致一个产品族中有很多不同产品，使用new或工厂模式时，传入过多参数造成不便。</p>
<p>Builder模式是分步构建对象的模式，是逐个产品进行构建，用一个配置类对这些步骤进行统筹，然后将所有信息交给构建器完成构建对象。</p>
<p>本例中，用门票展示，门票包含普通成年人票、老人票、儿童票、军属票。</p>
<p>首先创建配置类 TicketHelper，帮助我们一步步完成构建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickerHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildAdult</span> <span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出模拟构建成人票逻辑，"</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildChild</span> <span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出模拟构建儿童票逻辑，"</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildElderly</span> <span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出模拟构建老人票逻辑，"</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSoldier</span> <span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出模拟构建军属票逻辑，"</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要一个构建类 TicketBuilder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">builder</span> <span class="params">(TicketHelper helper)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过配置类TicketHelper构建门票信息"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成门票构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TicketHelper helper = <span class="keyword">new</span> TicketHelper();</span><br><span class="line">helper.buildAdult(<span class="string">"成人票"</span>);</span><br><span class="line">helper.buildChild(<span class="string">"儿童票"</span>);</span><br><span class="line">helper.buildElderly(<span class="string">"老人票"</span>);</span><br><span class="line">helper.buildSoldier(<span class="string">"军属票"</span>);</span><br><span class="line">Object ticket = TicketBuilder.builder(helper);</span><br></pre></td></tr></table></figure>
<p> </p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%90%8E%E7%AB%AF/"># 后端</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/03/23/MyBatis-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">MyBatis-1-核心组件</a>
            
            
            <a class="next" rel="next" href="/2021/03/20/B%E7%AB%99%E5%8A%A8%E6%80%81%E8%AF%84%E8%AE%BA%E5%8C%BA%E6%8A%BD%E5%A5%96/">B站动态评论区抽奖</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© gaylong9 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
